%!TEX root=ndma.tex
\newcommand{\eq}[1]{#1}
\newcommand{\syncQ}{Q_{\syncp}}
\newcommand{\syncW}[1]{\weight{#1}_{\syncp}}
\newcommand{\syncAss}{\rho_0^{\syncp}}
\newcommand{\syncInit}{q_0^{\syncp}}
\newcommand{\syncTr}[1]{\xymatrix@C-=4ex{\ar[r]^{#1}&\!_{\syncp}}}
\newcommand{\syncHtr}[2]{\xymatrix@C-=4ex{\ar[r]^{#1}_{#2}&\!_{\syncp}}}
\newcommand{\regrule}{\textsc{(Reg)}}
\newcommand{\allrule}{\textsc{(Alloc)}}
\newcommand{\cproj}{\pi}

The product of finite automata is an operation that, given two automata, produces a single one whose states are pairs $(q_1,q_2)$ of states of the original automata and transitions are those both states can do. In this section we define a similar operation on the underlying \emph{transition structures} of \hdmas{}, i.e.\ on tuples $\tstr = (Q,\weight{-},q_0,\rho_0,\trarrow)$. The difficulty here is handling registers: when forming pairs of states, we cannot simply make the union of their registers, because some of these registers could be assigned the same value, but assignments are injective. Therefore states have the form $(q_1,q_2,R)$, where $R$ is a relation telling which registers of $q_1$ and $q_2$ are assigned the same value, and thus represent the same register in the overall state. This is formally implemented by quotienting registers w.r.t.\ the equivalence relation induced by $R$.

Given two transition structures $\tstr_i = (Q_i,\weight{-}_i,q_0^i,\rho_0^i,\trarrow_i)$, now we define their synchronized product $\tstr_1 \syncp \tstr_2$. We denote with
$Reg(q_1,q_2)$ the set of relations that we allow to appear in states of $\tstr_1 \syncp \tstr_2$ where $q_1$ and $q_2$ are paired
\[
	Reg(q_1,q_2) := \{ R \subseteq \weight{q_1}_1 \times \weight{q_2}_2 \mid (x_1,y_1),(x_2,y_2) \in R \implies x_1 \neq x_2 \land y_1 \neq y_2 \}
\]
We avoid relations where two (or more) registers $x_1,x_2$ of $q_1$ are paired with the same one of $q_2$ or viceversa, because this would mean that $x_1$ and $x_2$ should be assigned the same value, but assignments are injective. Notice that $R \in Reg(q_1,q_2)$ is such that equivalence classes of $R^*$ have cardinality at most two.


\begin{definition}[Synchronized product of transition structures]
\label{def:syncp}
%Given two transition structures $\tstr_1,\tstr_2$, their \emph{synchronized product} 
$\tstr_1 \syncp \tstr_2$ is the transition structure $(\syncQ,\syncW{-},\syncInit,\syncAss,\syncTr{\quad})$ defined as follows:
\begin{itemize}
	\item $\syncQ := \bigcup_{q_1 \in Q_1,q_2 \in Q_2} \{(q_1,q_2)\} \times Reg(q_1,q_2)$;
	%
	\item $\syncW{(q_1,q_2,R)} := (\weight{q_1}_1 \cup \weight{q_2}_2)_{/R^*}$, for $(q_1,q_2,R) \in \syncQ$;
	%
	\item $\syncInit := (q_0^1,q_0^2,R_0)$, where $R_0:= \{ (x_1,x_2) \in \weight{q_0^1}_1 \times \weight{q_0^2}_2 \mid \rho_0^1(x_1) = \rho_0^2(x_2) \}$;
	%
	\item $\rho_0([x]_{R_0^*}) = \rho_0^i (x)$ whenever $x \in \weight{q_0^i}_i$, $i \in \{1,2\}$; 
	%(well-defined by definition of $R_0$);
	%
	\item transitions are generated by the following rules
	%
		\begin{mathpar}
			\inferrule[(Reg)]
			{ q_1 \htrind{l_1}{\sigma_1}{1} q_1' \\
			q_2 \htrind{l_2}{\sigma_2}{2} q_2'
			\\\\
			l_i \in \names \\ [l_i]_{R^*} = \{l_1,l_2\} \cap \names}
			{ (q_1,q_2,R) \syncHtr{[l_i]_{R^*}}{\sigma}
			(q_1',q_2',S) } 
			%}
			\and
			\inferrule[(Alloc)]
			{ q_1 \htrind{l_1}{\sigma_1}{1} q_1' \\ q_2 \htrind{l_2}{\sigma_2}{2} q_2' \\ l_1,l_2 = \star} 
			{ (q_1,q_2,R) \syncHtr{\star}{\sigma_\star} (q_1',q_2',S) }
		\end{mathpar}
	\begin{align*}
		S &:= \sigma_2^{-1} \circ R \cup \{(l_1,l_2)\} \circ \sigma_1 
		\\[2ex]
		\sigma([x]_{S^*}) &:= 
		\begin{cases}
			[\sigma_i(x)]_{R^*} & x \in \weight{q'_i}_i \land \sigma_i(x) \neq \star \\
			[l_{3-i}]_{R^*} & x \in \weight{q'_i}_i \land \sigma_i(x) = \star 
			%\land l_{3-i} \neq \star \\
			%\star & 
		\end{cases}
		\\[2ex]
		\sigma_\star([x]_{S^*}) &:= 
		\begin{cases}
			[\sigma_i(x)]_{R^*} & x \in \weight{q'_i}_i \land \sigma_i(x) \neq \star \\
			\star & x \in \weight{q'_i}_i \land \sigma_i(x) = \star 
		\end{cases}
	\end{align*}
\end{itemize}
\end{definition}
%
The definition of $\syncInit$ motivates the presence of relations in states: $R_0$ keeps track of registers that are assigned the same value by $\rho_0^1$ and $\rho_0^2$. These form the same register of $\syncInit$, so $\syncAss$ is well-defined.

The synchronization mechanism is implemented by rules \regrule{} and \allrule{}: they compute transitions of $(q_1,q_2,R) \in \syncQ$ from those of $q_1$ and $q_2$ as follows.
If the transitions of $q_1$ and $q_2$ are both labelled by registers, say $l_1$ and $l_2$, and these registers correspond to the same one in $(q_1,q_2,R)$ (condition $[l_i]_{R^*} = \{l_1,l_2\}$), then \regrule{} infers a transition labelled with $[l_i]_{R^*}$ (the specific $i$ is unrelevant). The target state of this transition is made of those of the transitions from $q_1$ and $q_2$, plus a relation $S$ obtained by translating $R$-related registers to $S$-related registers via $\sigma_1$ and $\sigma_2$. The pair $(l_1,l_2)$ added to $R$ in the definition of $S$ has no effect, as it is already in $R$; it will be useful in the following. The inferred history $\sigma$ just combines $\sigma_1$ and $\sigma_2$, consistently with $S^*$.

\regrule{} also handles the situation when a fresh name is consumed from either state, for instance $q_2$. The synchronization can happen anyway, but this name must already be assigned to the register $l_1$ appearing in the label of the transition of $q_1$. Therefore the inferred label is $[l_1]_{R^*}$. The target relation $S$ is as before, except for the following situation: suppose there are $l'_1$ and $l'_2$ such that $\sigma_1(l'_1) = l_1$ and $\sigma_2(l'_2) = \star$; after $q_1$ and $q_2$ perform their transitions, both these registers are assigned the same value, so we must have $(l'_1,l'_2) \in S$. The presence of this pair in $S$ is enforced by adding $(l_1,\star)$ to $R$ when computing $S$. This addition is harmless, because $[l_1]_{R^*}$ is a singleton (rule premise $[l_1]_{R^*} = \{l_1,\star\} \cap \names = \{l_1\}$), so no additional, inconsistent identifications are added to $S^*$ due to transitivity. If either $l_1$ or $\star$ is not in the image of the corresponding history map, then augmenting $R$ has no effect, as the relational composition discards $(l_1,\star)$. Finally, the inferred history $\sigma$ should map $[l_2']_{S^*}$ to $[l_1]_{R^*}$: this is treated by the second case of its definition; all the other values are mapped as before.

Transitions of $q_1$ and $q_2$ consuming a fresh name are turned by \allrule{} into a unique transition with freshness: $S$ is computed by adding $(\star,\star)$ to $R$, thus the registers to which the fresh name is assigned (if any) form one register in the overall state; the inferred history $\sigma_\star$ gives the freshness status to this register, and acts as usual on other registers.

%\begin{lemma}
%$\tstr_1 \syncp \tstr_2$ is deterministic.
%\end{lemma}
%\begin{proof}
%We have to prove that, for each $(q_1,q_2,R) \in \syncQ$ and each $l \in \syncW{(q_1,q_2,R)}$, there is a unique transition  $(q_1,q_2,R) \htr{l}{\sigma} (q_1',q_2',R')$. This essentially follows from determinism of $\tstr_1$ and $\tstr_2$. For the existence part: if $l = \{l_1,l_2\}$, then we take $q_i \htrind{l_i}{\sigma_i}{i} q_i'$, $i=1,2$, and we apply \regrule{}; if $l= \{l_1\}$ (resp.\ $l_2$) then we apply again \regrule{}, but this time we take a transition of $q_2$ with $l_2 = \star$ (resp.\ $q_1$ and $l_1$); if $l = \star$, we take transitions of $q_1$ and $q_2$ both labelled with $\star$. The uniqueness follows from the fact that, in all the cases we just listed, there is only one transition of each $q_i$ as required.
%
%\end{proof}

\begin{remark}
\label{rem:syncp-fin-det}
$\tstr_1 \syncp \tstr_2$ is finite-state and deterministic. In fact, every set in the definition of $\syncQ$ is finite, and cartesian products, powerset and finite union of finite sets again yield finite sets. As for determinism, given $(q_1,q_2,R) \in \syncQ$, each $l \in \syncW{(q_1,q_2,R)} \cup \{\star\}$ uniquely determines which labels $l_1$ and $l_2$ should appear in the rule premises (e.g. if $l = \{l_1\}$, with $l_1 \in \weight{q_1}_1$, then $l_2 = \star$), and by determinism each $q_i$ can do a unique transition labeled by $l_i$.
\end{remark}
%
%The state space $\syncQ$ contains some inconsistent states, for instance $(q_1,q_2,R)$ such that $(x_1,y_1),(x_1,y_2) \in R$, which implies $[x_1]_{R^*} = \{x_1,y_1,y_2\}$. This means that $y_1$ and $y_2$ must be assigned the same value in $q_2$, but this is not possible, as register assignments are injective. We call \emph{well-formed} those state without any such inconsistencies.



%\begin{definition}
%A state $(q_1,q_2,R) \in \syncQ$ is \emph{well-formed} whenever, for each $(x_1,y_1)$, $(x_2,y_2) \in R$, $(x_1,y_1) \neq (x_2,y_2)$ implies $x_1 \neq x_2$ and $y_1 \neq y_2$. Or, equivalently, each $[x]_{R^*} \in \syncW{(q_1,q_2,R)}$ has cardinality at most two.
%\end{definition}
%
%\begin{proposition}
%Given $(q_1,q_2,R) \syncHtr{l}{\sigma} (q_1',q_2',S)$, if $(q_1,q_2,R)$ is well-formed then so is $(q_1',q_2',S)$.
%\end{proposition}
%\begin{proof}
%Injective functions and their inverses, seen as relations, satisfy the constaints on $R$ required by well-formedness, so also their composition with $R$ does. \qed
%\end{proof}


%
%Let the configuration graph of a transition structure be as in \cref{def:config-graph}. We say that $((q_1,q_2,R),\rho) \in \confs(\tstr_1 \syncp \tstr_2)$ is well-formed is so is $(q_1,q_2,R)$.
Now we want to study the relation between the configuration graph of $\tstr_1 \syncp \tstr_2$ and those of $\tstr_1$ and $\tstr_2$. 

\begin{definition}[Configuration projection]
Let $((q_1,q_2,R),\rho) \in \confs(\tstr_1 \syncp \tstr_2)$. Its $i$-th projection, denoted $\cproj_i$, is defined as follows
\[
	\cproj_i((q_1,q_2,R),\rho) := (q_i,\rho_i) \qquad \rho_i := \lambda x \in \weight{q_i}_i.\rho([x]_{R^*}) \enspace .
\]
\end{definition}
%
%Not all elements of $\confs(\tstr_1 \syncp \tstr_2)$, once projected, give rise to proper configurations. 
%
%
Projections always produce valid configurations in $\confs(\tstr_1)$ and $\confs(\tstr_2)$: injectivity of $\rho_i$ follows from the definition of $Reg(q_1,q_2)$, ensuring that each $x \in \weight{q_i}_i$ appears in exactly one equivalence class of $R^*$. The correspondence between edges is formalized as follows.

\begin{proposition}
\label{prop:edges-correspondence}
Given $C \in \confs(\tstr_1 \syncp \tstr_2)$:
\begin{enumerate}[(i)]
	\item if $C \tr{a} C'$ then $\cproj_1(C) \tr{a} \cproj_1(C')$ and $\cproj_2(C) \tr{a} \cproj_2(C')$;
	\label{sync-to-each}
	\item if $\cproj_1(C) \trind{a}{1} C_1$ and $\cproj_2(C) \trind{a}{1} C_2$, then there is $C'$ such that $C\tr{a} C'$ and $\cproj_1(C) = C_1$,$\cproj_2(C) = C_2$.
	\label{each-to-sync}
\end{enumerate}
\end{proposition}
%\begin{proposition}
%\label{prop:edges-correspondence}
%For all $C,C' \in \confs(\tstr_1 \syncp \tstr_2)$, $C \tr{a} C'$ then $\cproj_1(C) \tr{a} \cproj_1(C')$ if and only if $\cproj_2(C) \tr{a} \cproj_2(C')$.
%\end{proposition}
%
\begin{corollary}
\label{cor:paths-correspondence}
Let $C_0 = (\syncInit,\rho_0)$. We have a path $C_0 \tr{a_0} \dots \tr{a_{n-1}} C_n$ in the configuration graph of $\tstr_1 \syncp \tstr_2$ if and only if we have paths $\cproj_i(C_0) \tr{a_0} \dots \tr{a_{n-1}} \cproj_i(C_n)$ in the configuration graphs of $\tstr_i$, for $i=1,2$.
%, for all $i=1,2$ and $n \in \mathbb{N} \cup \{\omega\}$.
\end{corollary}
%
When applied to infinite paths, this result allows establishing a relation between states that are visited infinitely often.
%leads to the following.
%
\begin{theorem}
\label{thm:inf-correspondence}
Given $\alpha \in \names^\omega$, let $r$ be a run for $\alpha$ in the configuration graph of $\tstr_1 \syncp \tstr_2$, and let $r_1$ and $r_2$ the corresponding paths for $\tstr_1$ and $\tstr_2$, according to \cref{cor:paths-correspondence}. Then $\pi_1(Inf(r)) = Inf(r_1)$ and $\pi_2(Inf(r)) = Inf(r_2)$.
\end{theorem}
%

%Now we have a way
%Then, given two \hdmas{} $\autom_1 = (\tstr_1,\acc_1)$ and $\autom_2 = (\tstr_2,\acc_2)$, we can construct an automaton $\autom_{\syncp} = (\tstr_1 \syncp \tstr_2,\acc_\syncp)$, which is a proper \hdma{} thanks to \cref{rem:syncp-fin-det}, where  $\acc_\syncp$ is an accepting set defined in function of $\acc_1$ and $\acc_2$. This will be fundamental for 



