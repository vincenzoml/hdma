%!TEX root=ndma.tex
\newcommand{\eq}[1]{#1}
\newcommand{\syncQ}{Q_{\syncp}}
\newcommand{\syncW}[1]{\weight{#1}_{\syncp}}
\newcommand{\syncAss}{\rho_0^{\syncp}}
\newcommand{\syncInit}{q_0^{\syncp}}
\newcommand{\syncTr}[1]{\xymatrix@C-=4ex{\ar[r]^{#1}&\!_{\syncp}}}
\newcommand{\syncHtr}[2]{\xymatrix@C-=4ex{\ar[r]^{#1}_{#2}&\!_{\syncp}}}
\newcommand{\regrule}{\textsc{(Reg)}}
\newcommand{\allrule}{\textsc{(Alloc)}}
\newcommand{\cproj}{\pi}

The product of two finite automata uses the well-known \emph{synchronised product} construction. In this section we define this operation on the underlying \emph{transition structures} of \hdmas{}, i.e.\ on tuples $\tstr = (Q,\weight{-},q_0,\rho_0,\trarrow)$ (we want to be parametric w.r.t.\ the accepting condition). One should  be careful in handling registers. When forming pairs of states, some of these registers could be constrained to have the same value.
%assignments are injective. 
Thus, states have the form $(q_1,q_2,R)$, where $R$ is a relation, linking registers of $q_1$ and $q_2$, that represent the same register in the synchronised product. This is implemented by quotienting registers w.r.t.\ the equivalence $R^*$ induced by $R$; the construction is similar to the case of register automata, and to the construction of products in named sets given in \cite{CianciaM10}.

Given two transition structures $\tstr_i = (Q_i,\weight{-}_i,q_0^i,\rho_0^i,\trarrow_i)$, $i=1,2$, we define their synchronized product $\tstr_1 \syncp \tstr_2$. Given $q_1 \in Q_1$,$q_2 \in Q_2$, $Reg(q_1,q_2)$ is the set of relations that are allowed to appear in states of the form $(q_1,q_2,R)$, namely those $R \subseteq \weight{q_1}_1 \times \weight{q_2}_2$ such that, for each $(x,y) \in R$, there is no other $(x',y') \in R$ with $x'=x$ or $y'=y$. This avoids inconsistent states where the individual assignment for $q_1$ or $q_2$ would not be injective. In the following we assume $[x]_{R^*}$ (the canonical representative of the equivalence class of $x$ in $R^*$) to be $\{x\}$ when $x$ does not appear in any pair of $R$.

% These relations, when appearing within states of $\tstr_1 \syncp \tstr_2$, avoid two register of the same state to be assigned the same value.

% to be paired with the same of $q_2$ or viceversa, because this would mean that $x_1$ and $x_2$ should be assigned the same value, but assignments are injective. We assume that $R$ is implicitly 

%that we allow to appear in states of $\tstr_1 \syncp \tstr_2$ where $q_1$ and $q_2$ are paired
%\[
%	Reg(q_1,q_2) := \{ R \subseteq \weight{q_1}_1 \times \weight{q_2}_2 \mid (x_1,y_1),(x_2,y_2) \in R \implies x_1 \neq x_2 \land y_1 \neq y_2 \}
%\]
%We avoid relations where two (or more) registers $x_1,x_2$ of $q_1$ are paired with the same one of $q_2$ or viceversa, because this would mean that $x_1$ and $x_2$ should be assigned the same value, but assignments are injective. Notice that $R \in Reg(q_1,q_2)$ is such that equivalence classes of $R^*$ have cardinality at most two.


\begin{definition}
\label{def:syncp}
$\tstr_1 \syncp \tstr_2$ is the tuple $(\syncQ,\syncW{-},\syncInit,\syncAss,\syncTr{\quad})$ where:
\begin{itemize}
	\item 
	%$\syncQ := \bigcup_{q_1 \in Q_1,q_2 \in Q_2} \{(q_1,q_2)\} \times Reg(q_1,q_2)$;
	$\syncQ := \{ (q_1,q_2,R) \mid q_1 \in Q_1,q_2 \in Q_2,R \in Reg(q_1,q_2)\}$;
	%
	\item $\syncW{(q_1,q_2,R)} := (\weight{q_1}_1 \cup \weight{q_2}_2)_{/R^*}$, for $(q_1,q_2,R) \in \syncQ$;
	%
	\item $\syncInit := (q_0^1,q_0^2,R_0)$, where $R_0:= \{ (x_1,x_2) \in \weight{q_0^1}_1 \times \weight{q_0^2}_2 \mid \rho_0^1(x_1) = \rho_0^2(x_2) \}$;
	%
	\item $\rho_0([x]_{R_0^*}) = \rho_0^i (x)$ whenever $x \in \weight{q_0^i}_i$, $i \in \{1,2\}$; 
	%
	\item transitions are generated by the following rules
\end{itemize}
	%
		\begin{mathpar}
			\inferrule[(Reg)]
			{ q_1 \htrind{l_1}{\sigma_1}{1} q_1' \\
			q_2 \htrind{l_2}{\sigma_2}{2} q_2' 
			\\\\
			\exists i \in \{1,2\} : l_i \in \names \land [l_i]_{R^*} = \{l_1,l_2\} \cap \names}
			%\cap \names \quad i \in \{1,2\}}
			{ (q_1,q_2,R) \syncHtr{[l_i]_{R^*}}{\sigma_R}
			(q_1',q_2',S) } 
			%}
			\quad\;
			\inferrule[(Alloc)]
			{ q_1 \htrind{l_1}{\sigma_1}{1} q_1' \quad q_2 \htrind{l_2}{\sigma_2}{2} q_2' \quad l_1,l_2 = \star} 
			{ (q_1,q_2,R) \syncHtr{\star}{\sigma_A} (q_1',q_2',S) }
		\end{mathpar}
	%\vspace{-2ex}
	where $S := \sigma_2^{-1} \circ R \cup \{(l_1,l_2)\} \circ \sigma_1 $ and
% and the mappings $\sigma_\tau$, for $\tau \in \{A,R\}$, are as follows
	\begin{align*}
		%S &:= \sigma_2^{-1} \circ R \cup \{(l_1,l_2)\} \circ \sigma_1 
		%\\[2ex]
		\sigma_\tau([x]_{S^*}) &:= 
		\begin{cases}
			[\sigma_i(x)]_{R^*} & x \in \weight{q'_i}_i \land \sigma_i(x) \neq \star \\
			[l_{3-i}]_{R^*} & x \in \weight{q'_i}_i \land \sigma_i(x) = \star \land \tau = R \\
			\star & x \in \weight{q'_i}_i \land \sigma_i(x) = \star \land \tau = A
		\end{cases}
	\end{align*}
%\end{itemize}
\end{definition}
%
 Before explaining in detail the formal definition, we remark that the relation $S$ is well defined, i.e.\ it belongs to $Reg(q_1',q_2')$: the addition of $\{(l_1,l_2)\}$ to $R$ is harmless, as will be explained in the following, and $\sigma_1$ and $\sigma^{-1}_2$ can never map the same value to two different values (as they are functions) or vice versa (as they are injective).
%
The definition of $\syncInit$ motivates the presence of relations in states: $R_0$-related registers are the ones that are assigned the same value by $\rho_0^1$ and $\rho_0^2$; these form the same register of $\syncInit$, so $\syncAss$ is well-defined. The synchronization mechanism is implemented by rules \regrule{} and \allrule{}: they compute transitions of $(q_1,q_2,R) \in \syncQ$ from those of $q_1$ and $q_2$ as follows.

Rule \regrule{} handles two cases. First, if the transitions of $q_1$ and $q_2$ are both labelled by registers, say $l_1$ and $l_2$, and these registers correspond to the same one in $(q_1,q_2,R)$ (condition $[l_i]_{R^*} = \{l_1,l_2\}$, recalling that $[l_i]_{R^*}$ cannot contain more labels due to injectivity of register maps), then \regrule{} infers a transition labelled with $[l_i]_{R^*}$ (the specific $i$ is not relevant). The target state of this transition is made of those of the transitions from $q_1$ and $q_2$, plus a relation $S$ obtained by translating $R$-related registers to $S$-related registers via $\sigma_1$ and $\sigma_2$. In this case, adding the pair $(l_1,l_2)$ to $R$ in the definition of $S$ has no effect, as it is already in $R$. The inferred history $\sigma_R$ just combines $\sigma_1$ and $\sigma_2$, consistently with $S^*$.

The other case for \regrule{} is when a fresh name is consumed from just one state, e.g.\ $q_2$.
This name must coincide with the value assigned to the register $l_1$ labelling the transition of $q_1$. Therefore the inferred label is $[l_1]_{R^*}$. The target relation $S$ changes slightly. Suppose there are $l'_1 \in \weight{q'_1}$ and $l'_2\in \weight{q'_2}$ such that $\sigma_1(l'_1) = l_1$ and $\sigma_2(l'_2) = \star$; after $q_1$ and $q_2$ perform their transitions, both these registers are assigned the same value, so we require $(l'_1,l'_2) \in S$. This pair is forced to be in $S$ by adding $(l_1,\star)$ to $R$ when computing $S$. This does not harm well-definedness of $S$, because $[l_1]_{R^*}$ is a singleton (rule premise $[l_1]_{R^*} = \{l_1,\star\} \cap 	\names = \{l_1\}$), so no additional, inconsistent identifications are added to $S^*$ due to transitivity. If either $l_1$ or $\star$ is not in the image of the corresponding history map, then augmenting $R$ has no effect, as the relational composition discards $(l_1,\star)$. The history $\sigma_R$ should map $[l_2']_{S^*}$ to $[l_1]_{R^*}$: this is treated by the second case of its definition; all the other values are mapped as before.

Transitions of $q_1$ and $q_2$ consuming a fresh name on both sides are turned by \allrule{} into a unique transition with freshness: $S$ is computed by adding $(\star,\star)$ to $R$, thus the registers to which the fresh name is assigned (if any) form one register in the overall state; the inferred history $\sigma_A$ gives the freshness status to this register, and acts as usual on other registers.

\begin{remark}
\label{rem:syncp-fin-det}
$\tstr_1 \syncp \tstr_2$ is finite-state and deterministic. In fact, every set in the definition of $\syncQ$ is finite.
%, and cartesian products, powerset and finite union of finite sets again yield finite sets.
As for determinism, given $(q_1,q_2,R) \in \syncQ$, each $l \in \syncW{(q_1,q_2,R)} \cup \{\star\}$ uniquely determines which labels $l_1$ and $l_2$ should appear in the rule premises (e.g. if $l = \{l_1\}$, with $l_1 \in \weight{q_1}_1$, then $l_2 = \star$), and by determinism each $q_i$ can do a unique transition labeled by $l_i$.
\end{remark}
%
We shall now relate the configuration graphs of $\tstr_1 \syncp \tstr_2$, $\tstr_1$ and $\tstr_2$.
%
\begin{definition}
Let $((q_1,q_2,R),\rho) \in \confs(\tstr_1 \syncp \tstr_2)$. Its $i$-th projection, denoted $\cproj_i$, is defined as
$\cproj_i((q_1,q_2,R),\rho) = (q_i,\rho_i)$ with $\rho_i := \lambda x \in \weight{q_i}_i.\rho([x]_{R^*})$
\end{definition}
%
Projections always produce valid configurations in $\confs(\tstr_1)$ and $\confs(\tstr_2)$: injectivity of $\rho_i$ follows from the definition of $Reg(q_1,q_2)$, ensuring that two different $x_1,x_2 \in \weight{q_i}_i$ cannot belong to the same equivalence class of $R^*$, i.e.\ cannot have the same image through $\rho_i$. The correspondence between edges is formalized as follows.

\begin{proposition}
%\todo{condensare, usando $\pi_i$ invece di $\pi_1,\pi_2$?}
\label{prop:edges-correspondence}
Given $C \in \confs(\tstr_1 \syncp \tstr_2)$: 
\begin{inparaenum}[(i)]
	\item %\vskip -6pt 
	if $C \tr{a} C'$ then $\cproj_i(C) \tr{a} \cproj_i(C')$, $i = 1,2$;
	% and $\cproj_2(C) \tr{a} \cproj_2(C')$;
	\label{sync-to-each}
	\item if $\cproj_i(C) \trind{a}{i} C_i$, $i=1,2$, 
	%and $\cproj_2(C) \trind{a}{1} C_2$, 
	then $\exists C' : C\tr{a} C'$ and $\cproj_i(C) = C_i$.
	%,$\cproj_2(C) = C_2$.
	\label{each-to-sync}
\end{inparaenum}
% \begin{enumerate}[(i)]
% 	\item if $C \tr{a} C'$ then $\cproj_i(C) \tr{a} \cproj_i(C')$, $i = 1,2$;
% 	% and $\cproj_2(C) \tr{a} \cproj_2(C')$;
% 	\label{sync-to-each}
% 	\item if $\cproj_i(C) \trind{a}{i} C_i$, $i=1,2$, 
% 	%and $\cproj_2(C) \trind{a}{1} C_2$, 
% 	then there is $C'$ s.t.\ $C\tr{a} C'$ and $\cproj_i(C) = C_i$.
% 	%,$\cproj_2(C) = C_2$.
% 	\label{each-to-sync}
% \end{enumerate}
\end{proposition}
%
\begin{corollary}
\label{cor:paths-correspondence}
Let $C_0 = (\syncInit,\rho_0)$. We have a path $C_0 \tr{a_0} \dots \tr{a_{n-1}} C_n$ in the configuration graph of $\tstr_1 \syncp \tstr_2$ if and only if we have paths $\cproj_i(C_0) \tr{a_0} \dots \tr{a_{n-1}} \cproj_i(C_n)$ in the configuration graphs of $\tstr_i$, for $i=1,2$. The correspondence clearly holds also for infinite paths, i.e.\ runs.
\end{corollary}
%
This result allows us to relate the $\Inf$ of runs in the defined transition structures.%\todo{check sentence}
%
\begin{theorem}
\label{thm:inf-correspondence}
Given $\alpha \in \names^\omega$, let $r$ be a run for $\alpha$ in the configuration graph of $\tstr_1 \syncp \tstr_2$, and let $r_1$ and $r_2$ be the corresponding 
%\todo{Non capisco: paths o runs? Estenderei il corollario per parlare di runs, se Ã¨ banale} 
runs for $\tstr_1$ and $\tstr_2$, according to \cref{cor:paths-correspondence}. Then $\pi_1(Inf(r)) = Inf(r_1)$ and $\pi_2(Inf(r)) = Inf(r_2)$.
\end{theorem}