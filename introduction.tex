%!TEX root=ndma.tex

% Explain what kind of languages do we get (refer to the example in the paper)

%\todo{Dire che la prova UP non Ã¨ banale. Dire che finite representation allows for a very simple proof of decidability of emptiness}

Languages of infinite words are of paramount importance in logics and computer science. Their usage scenarios range from decidability proofs in logics, 
 to applications of relevant practical impact, such as model checking and learning of logical properties. Just as in the case of finite words, these languages are typically defined on finite alphabets. However, there are cases in which the alphabet is infinite, e.g.\
%; think e.g., about 
\emph{data words} (see \cite{Seg06} for  a survey), or \emph{nominal calculi} \cite{MPW92}. Languages of \emph{finite} words over infinite alphabets have thoroughly been studied in the literature \cite{KF94,Tze11}. 
It is nowadays clear that register automata, and languages of infinite alphabets, are also expressible as automata over \emph{nominal sets} \cite{GP02}, which are in turn equivalent  to history-dependent automata \cite{Pistore99,StatonF06,GadducciMM06} (see \cite{CianciaTuostoTR} for an introduction). 

Several recent papers (see e.g., \cite{TOMOYUKI,GABBAYCIANCIA}) deal with various kinds of nominal automata. The paper \cite{MikLICS} discusses languages that are expressible using generalised notions of nominal sets. The same point of view led to the developments described in \cite{MikPOPL12}, and \cite{PittsPOPL13}. All these developments may be identified as parts of an emergent
\emph{nominal computation theory}. Nominal sets introduce the key notion of \emph{finite support}, that can be roughly explained as a finite memory property with respect to the symbols that appear on a word. From the automata-theoretic perspective, languages of finite words over infinite (nominal) alphabets are treated in a satisfactory way by resorting to an \emph{orbit-finite} set of states \cite{CianciaMontanariIC?}, equipped with an \emph{equivariant} transition relation, and equivariant acceptance condition. Finite words have finite support, thus the set of all words forms a nominal set. 

The case of infinite words over nominal alphabets is more problematic, as an infinite word over an infinite alphabet is generally not finitely supported. Consider a machine that reads any symbol from an infinite, countable alphabet, and never stores it. Clearly, such a machine has finite (empty) memory. The set of its traces is simply described as the set of all infinite words over the alphabet. However, in the language we have various species of words. Some of them are finitely supported, e.g.\ words that consist of the infinite repetition of a finite word. Some others are not finitely supported, such as the word enumerating all the symbols of the alphabet. Such words lay inherently out of the realm of nominal sets. However, the existence of these words does not give to the language infinite memory. More precisely,  words without finite support can not be ``singled out'' by a finite memory machine; if a machine accepts one of those, then it will accept infinitely many others, including finitely supported words.  

The aim of this work is to translate the intuitions in the previous paragraphs into precise mathematical terms, in order to define a class of languages of infinite words over infinite alphabets, enjoying finite-memory properties. We extend automata over nominal sets to handle infinite words, by imposing a (Muller-style) acceptance condition 
over the \emph{orbits} (not the states!) of automata. By doing so, it turns out that our languages not only are finite-memory, but they retain computational properties, such as closure under boolean operations and decidability of emptiness (thus, containment and equivalence). Moreover, we prove that the obtained languages are determined by their \emph{ultimately periodic} fragments, just as in the classical case \cite{}. This clarifies the intuition that we proposed above, about accepting ``infinitely many other words'' for machines accepting a word which is not finitely supported. 
%
The proof itself is non-trivial, as one has to deal with freshness and finite memory.
Being determined by ultimately periodic fragments is
a relevant property for classical automata, whose consequences have probably not yet been explored in full.
%
For example, such property has been used in learning of languages of infinite words \cite{Emerson}, or to find canonical representatives up-to language equivalence, in a coalgebraic flavour \cite{CV12}. We expect that further exploitation of ultimately-periodic fragments may also be benificial for 
our automata.%



